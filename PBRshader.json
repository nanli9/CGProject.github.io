{
  "id": 2417,
  "name": "PBRshader",
  "fragment": "//片元着色器\r\nprecision highp float;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform vec3 cameraPosition;\r\nvarying vec3 fPosition;\r\nvarying vec3 fNormal;\r\nuniform float ka;\r\nuniform float kd;\r\nuniform float ks;\r\nvec3 lightcolor=vec3(1,1,1);\r\nuniform float shininess;\r\nuniform float roughness;\r\nuniform vec3 lightPosition;\r\nuniform samplerCube env;\r\n\r\n\r\nvec3 basecolor=vec3(0.5,0.5,0.5);\r\nvec3 globalAmbient=vec3(0.5,0.5,0.5);\r\n\r\nconst float PI = 3.14159265359;\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness);\r\nfloat GeometrySchlickGGX(float NdotV, float roughness);\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness);\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0);\r\n//漫反射项,公式见diney brdr 5-3\r\nfloat Diffuse_term(float Roughness, float NoV, float NoL, float VoH );\r\n//cosD = IDotH\r\nfloat Fresnel_Schlick_Coat( float cosD);\r\n// ----------------------------------------------------------------------------\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\r\n{\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float NdotH = max(dot(N, H), 0.0);\r\n    float NdotH2 = NdotH*NdotH;\r\n\r\n    float nom   = a2;\r\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n\r\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\r\n}\r\n// ----------------------------------------------------------------------------\r\nfloat GeometrySchlickGGX(float NdotV, float roughness)\r\n{\r\n    float r = (roughness + 1.0);\r\n    float k = (r*r) / 8.0;\r\n\r\n    float nom   = NdotV;\r\n    float denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n// ----------------------------------------------------------------------------\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\r\n{\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n// ----------------------------------------------------------------------------\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\r\n{\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\n//漫反射项,公式见diney brdr 5-3\r\nfloat Diffuse_term(float Roughness, float NoV, float NoL, float VoH )\r\n{\r\n  float FD90 = 0.5 + 2.0 * VoH * VoH * Roughness;\r\n\tfloat FdV = 1.0+ (FD90 - 1.0) * pow( 1.0 - NoV,5.0);\r\n\tfloat FdL = 1.0 + (FD90 - 1.0) * pow( 1.0 - NoL,5.0);\r\n\treturn ( (1.0/3.14) * FdV * FdL );\r\n}\r\n//cosD = IDotH\r\nfloat Fresnel_Schlick_Coat( float cosD) \r\n  \t\t{\r\n\t\t\t\tfloat oneMinusCosD = 1.0- cosD;\r\n\t\t\t\tfloat oneMinusCosDSqr = oneMinusCosD * oneMinusCosD;\r\n\t\t\t\tfloat fresnel = 0.04 +\r\n\t\t\t\t\t(1.0 - 0.04) * oneMinusCosDSqr * oneMinusCosDSqr * oneMinusCosD;\r\n\r\n\t\t\t\treturn fresnel;\r\n\t\t\t}\r\n\r\n  \r\n  ////\r\n  float TanTheta2( vec3 vec)\r\n  \t\t{\r\n\t\t\t\tfloat temp = 1.0 - vec.z * vec.z;\r\n\t\t\t\tif (temp <= 0.0)\r\n\t\t\t\t\treturn 0.0;\r\n\t\t\t\treturn temp / (vec.z * vec.z);\r\n\t\t\t}\r\n  float CosTheta2( vec3 vec)\r\n  { \r\n    return vec.z * vec.z;\r\n  }\r\n  float AbsCosTheta( vec3 vec) \r\n  { return  max(vec.z,0.0);\r\n  }\r\n  \r\n  float TanTheta(vec3 vec)\r\n  \t\t{\r\n\t\t\t\tfloat temp = 1.0 - vec.z * vec.z;\r\n\t\t\t\tif (temp <= 0.0)\r\n\t\t\t\t\treturn 0.0;\r\n\t\t\t\treturn temp*temp/vec.z;\r\n\t\t\t}\r\n  float CosTheta(vec3 vec) { return vec.z; }\r\n  \r\n  //参数1，中间向量，参数2，透明度\r\n  float GGX_D( vec3 wh, float alpha)\r\n\t\t{\r\n\t\t\tif(wh.z <= 0.0)\r\n      {\r\n        return 0.0;\r\n      }\r\n\t\t\tfloat tanTheta2 = TanTheta2(wh);\r\n\t\t\tfloat\tcosTheta2 = CosTheta2(wh);\r\n\t\t\tfloat root = alpha*1.0/(cosTheta2 * (alpha * alpha + tanTheta2));\r\n\t\t\treturn (1.0/3.14)* (root * root);\r\n\t\t}\r\n    \r\n    float SmithG(vec3 v, vec3 wh, float alpha)\r\n  \t{\r\n\t\t\tfloat tanTheta = max(TanTheta(v),0.0);\r\n\r\n\t\t\tif (tanTheta == 0.0)\r\n\t\t\t\treturn 1.0;\r\n\r\n\t\t\tif (dot(v, wh)*CosTheta(v) <= 0.0)\r\n\t\t\t\treturn 0.0;\r\n\r\n\t\t\tfloat root = alpha * tanTheta;\r\n\t\t\treturn 2.0/(1.0 + (1.0 + root*root)*(1.0 + root*root));\r\n\t\t}\r\n    \r\n    \r\n    float GGX_G(vec3 wo, vec3 wi,vec3 wh, float alpha)\r\n  \t{\r\n\t\t\treturn SmithG(wo, wh, alpha) * SmithG(wi, wh, alpha);\r\n\t\t}\r\n    \r\n  //清漆项\r\n  float ClearCoatTerm(vec3 wo,vec3 wi,vec3 wh,float IdotH,float roughness,float mclearcoat)\r\n  {\r\n    if (mclearcoat == 0.0)\r\n    {\r\n      return 0.0;\r\n    }   \r\n    float rough =0.005+(0.1-0.005)*roughness;\r\n    float D = GGX_D(wh, rough);\r\n  \tif (D == 0.0)\r\n    {\r\n      return 0.0;\r\n    }\r\n    float oneMinusCosD = 1.0-IdotH;\r\n    float oneMinusCosDSqr = oneMinusCosD * oneMinusCosD;\r\n    float F = Fresnel_Schlick_Coat(IdotH);\r\n    float G = GGX_G(wo, wi, wh, 0.25);\r\n    return mclearcoat * D * F * G / (4.0 * AbsCosTheta(wi)*AbsCosTheta(wo));\r\n  }\r\n  \r\n  vec3 computeEnvReflect(vec3 v,vec3 normal,samplerCube env)\r\n  {\r\n      vec3 ref=reflect(v,normal);\r\n      vec4 envcolor=textureCube(env,ref);\r\n      return envcolor.xyz;\r\n  }\r\n  \r\n  void main()\r\n{\r\n  vec3 P=fPosition.xyz;\r\n  vec3 N=normalize(fNormal);\r\n  vec3 ambient=ka*globalAmbient;\r\n  \r\n  vec3 L=normalize(lightPosition);\r\n  \r\n  float ln=max(0.0,dot(L,N));\r\n  vec3 diffuse=kd*lightcolor*ln;\r\n  vec3 V=normalize(cameraPosition-P);\r\n  vec3 H=normalize(L+V);\r\n  vec3 specular=vec3(0.0,0.0,0.0);\r\n  bool back=(dot(V,N)>0.0) && (dot(L,N)>0.0);\r\n  \r\n  vec3 diffusecolor=kd*globalAmbient+kd*basecolor*max(dot(N,L),0.0);\r\n  vec3 specularcolor=ks*lightcolor*pow(max(dot(N,H),0.0),shininess);\r\n  \r\n  vec3 r=reflect(-V,N);\r\n  vec3 envcolor=textureCube(env,r,5.0).xyz;\r\n  vec3 _color=diffusecolor+specularcolor+envcolor;\r\n  float s=1.0;\r\n  if(envcolor.x==0.0)\r\n  {\r\n      s=0.2;\r\n  }\r\n  gl_FragColor = vec4(diffusecolor, s);\r\n}",
  "vertex": "/**\n* Example Vertex Shader\n* Sets the position of the vertex by setting gl_Position\n*/\n\n// Set the precision for data types used in this shader\nprecision highp float;\nprecision highp int;\n\n// Default THREE.js uniforms available to both fragment and vertex shader\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\n\n// Default uniforms provided by ShaderFrog.\nuniform vec3 cameraPosition;\nuniform float time;\n\n\n// Default attributes provided by THREE.js. Attributes are only available in the\n// vertex shader. You can pass them to the fragment shader using varyings\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n\n// Examples of variables passed from vertex to fragment shader\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec2 vUv2;\nvarying vec3 fPosition;\nvarying vec3 fNormal;\n\nvoid main() {\n\n    // To pass variables to the fragment shader, you assign them here in the\n    // main function. Traditionally you name the varying with vAttributeName\n    vNormal = normal;\n    vUv = uv;\n    vUv2 = uv2;\n    \n    vPosition = position;\n    //世界坐标系下的顶点坐标\n    fPosition=(modelMatrix*vec4(position,1.0)).xyz;\n    //世界坐标系下的法线\n    fNormal=(modelMatrix*vec4(normal,1.0)).xyz;\n    // This sets the position of the vertex in 3d space. The correct math is\n    // provided below to take into account camera and object data.\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}",
  "uniforms": {
    "cameraPosition": {
      "name": "cameraPosition",
      "displayName": null,
      "type": "v3",
      "glslType": "vec3",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "time": {
      "name": "time",
      "displayName": null,
      "type": "f",
      "glslType": "float",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "env": {
      "name": "env",
      "displayName": null,
      "type": "t",
      "glslType": "samplerCube",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "resolution": {
      "name": "resolution",
      "displayName": null,
      "type": "v2",
      "glslType": "vec2",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "ka": {
      "name": "ka",
      "displayName": null,
      "type": "f",
      "glslType": "float",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "kd": {
      "name": "kd",
      "displayName": null,
      "type": "f",
      "glslType": "float",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "ks": {
      "name": "ks",
      "displayName": null,
      "type": "f",
      "glslType": "float",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "roughness": {
      "name": "roughness",
      "displayName": null,
      "type": "f",
      "glslType": "float",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "shininess": {
      "name": "shininess",
      "displayName": null,
      "type": "f",
      "glslType": "float",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    },
    "lightPosition": {
      "name": "lightPosition",
      "displayName": null,
      "type": "v3",
      "glslType": "vec3",
      "useGridHelper": false,
      "useRange": false,
      "range": null,
      "isRandom": false,
      "randomRange": null,
      "useToggle": false,
      "toggle": null,
      "description": ""
    }
  },
  "url": "http://shaderfrog.com/app/view/2417",
  "user": {
    "username": "FrankQi",
    "url": "http://shaderfrog.com/app/profile/andrewray"
  }
}